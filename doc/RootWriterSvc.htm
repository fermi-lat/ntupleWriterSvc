<h1>RootWriterSvc supplement</h1>
<p>The package
<a href="http://glast.stanford.edu/cgi-bin/cvsweb-SLAC/ntupleWriterSv">
ntupleWriterSvc</a>, defines a Service interface
<a href="http://glast.stanford.edu/cgi-bin/cvsweb-SLAC/ntupleWriterSvc/">
INtupleWriterSvc</a>. This interface is implemented by two concrete services:</p>
<ul>
  <li>nTupleWriterSvc: The original version, which is an interface to the Gaudi 
  tuple, which is in turn written out to a root file with the Gaudi 
  RootWriterSvc.</li>
  <li>RootTupleSvc: A new class, which is optimized for root files.</li>
</ul>
<p>A new function was added to the interface when RootTupleSvc was added:</p>
<blockquote>
  <div style="width: 647; height: 18; border-style: solid; border-width: 1; padding-left: 4; padding-right: 4; padding-top: 1; padding-bottom: 1">
    <font face="Helvetica,Arial" size="-1">&nbsp;virtual StatusCode addItem(const 
    std::string &amp; tupleName, const std::string&amp; itemName, const double* pval);</font></div>
</blockquote>
<p>This overloads a function with the same name, but with the important 
difference that the last argument is a <b>pointer </b>&nbsp;to a double, and is 
expected to be called only once, during initialization. This simplifies usage, 
especially since it is not required that every event is added to the tuple. Note 
that RootTupleSvc does not implement the old style, returning ERROR in that 
case.</p>
<p>The RootTupleSvc implementation has some important features:</p>
<ol>
  <li>The default for adding a row to the tuple is that it must be requested.</li>
  <li>The first argument in addItem is interpreted as the name of a TTree, which 
  will be created if the TTree does not exist. Thus, the ROOT file can have any 
  number of TTree's.</li>
  <li>There is access to the ROOT AutoSave&nbsp; functionality.</li>
  <li>It is possible to selectively add rows, with a new interface function<br>
&nbsp;<table border="1" cellpadding="2" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="42%" id="AutoNumber2">
    <tr>
      <td width="100%"><font SIZE="2"></font><font SIZE="2" COLOR="#0000ff">
      virtual</font><font SIZE="2"> </font><font SIZE="2" COLOR="#0000ff">bool</font><font SIZE="2"> 
      storeRowFlag(</font><font SIZE="2" COLOR="#0000ff">const</font><font SIZE="2"> 
      std::string&amp; tupleName, </font><font SIZE="2" COLOR="#0000ff">bool</font><font SIZE="2"> 
      flag);</font></td>
    </tr>
  </table>
  </li>
</ol>
<p>The properties are listed in the following table:</p>
<table border="1" cellpadding="3" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="91%" id="AutoNumber1">
  <tr>
    <th width="15%" bgcolor="#C0C0C0">Name</th>
    <th width="51%" bgcolor="#C0C0C0">Description</th>
    <th width="34%" bgcolor="#C0C0C0">Default</th>
  </tr>
  <tr>
    <td width="15%">filename</td>
    <td width="51%">&nbsp;The ROOT filename</td>
    <td width="34%">&quot;RootTupleSvc.root&quot;</td>
  </tr>
  <tr>
    <td width="15%">treename</td>
    <td width="51%">&nbsp;Default tree name to use if the &quot;tupleName&quot; argument 
    is empty</td>
    <td width="34%">&quot;1&quot;</td>
  </tr>
  <tr>
    <td width="15%">title</td>
    <td width="51%">&nbsp;Title for all TTree's</td>
    <td width="34%">&quot;Glast tuple&quot;</td>
  </tr>
  <tr>
    <td width="15%">defaultStoreFlag</td>
    <td width="51%">Store the row at the end of an event loop cycle. If false, 
    client must execute <i>storeRowFlag(true)</i> to save all trres in&nbsp; the current event. 
    Or, the client can execute <i>storeRowFlag(treename, true) </i>to save the 
    specific tree.</td>
    <td width="34%">false</td>
  </tr>
  <tr>
    <td width="15%">AutoSave</td>
    <td width="51%">Number of bytes to save at a time (ROOT default is 10000000)</td>
    <td width="34%">100000</td>
  </tr>
</table>
<p>Note that compared with nTupleWriterSvc, there is one drawback: since entries 
are not processed when a row is saved, there is no check for NAN values.</p>

